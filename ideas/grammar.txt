Gramática de descrição de objetos

Há 8 tipos de objeto:
    Parâmetro. Ex: "param a:[0, 10];" <- parâmetro a entre 0 e 10.
    Curva. Ex: "curve c = (cos t, sin t), t:[0, 2pi];" <- círculo unitário.
    Superfície. Ex: "surface s = (u, v, 0), u:[0, 1], v:[0,1];" <- quadrado 1x1.
    Definição. Ex: "define r = a+b;" <- define o símbolo r = a+b.
    Function. Ex: "function f(a,b) = 3a+b;" <- define a função f.
    Grade. Ex: "grid k:[0, 4], 4;" <- define k em {0, 1, 2, 3}.
    Point. Ex: "point p = (0,0,1);" <- define o ponto p.
    Vector. Ex: "vector v = (1, 1, 1) @ (0, 0, 0);" <- define o vetor v, desenhado na origem.

Um objeto pode fazer referência a outro definido anteriormente, mas apenas pontos e vetores podem se referir a uma grade.

Uma grade é um parâmetro que pode instanciar múltiplos pontos e vetores de mesma fórmula.
Por exemplo:
    grid k:[0,4], 4;
    point p = (k, 0, 0);
-> Isso faz com que p seja 4 pontos: (0, 0, 0) (1, 0, 0) (2, 0, 0) (3, 0, 0)

Pontos e vetores podem se referir a mais de uma grade, aumentando a dimensão da instanciação.
Isso é útil para desenhar campos vetoriais.

Símbolos pré-definidos: 
    e1 = (1, 0, 0)
    e2 = (0, 1, 0)
    e3 = (0, 0, 1)
    org = (0, 0, 0)
    pi, e
    exp, sqrt, log, len, sin, cos, tan

Multiplicação justaposta entre vetores indica produto escalar.
Multiplicação por asterisco entre vetores indica produto vetorial.

Aplicação de funções não precisa de parênteses, basta que o argumento seja da forma UNARY.
Uma função pode ser composta: f' para derivada total, f_x para derivada parcial, e f^u para potenciação.
As 3 formas podem ser combinadas.

Ex: sin^2 x = (sin x)^2
    f'^2 -1 = ( f'(-1) )^2

********************************

PROG    -> DECL PROG
PROG    -> DECL

DECL    -> param    id : INT ;
DECL    -> curve    id = ADD, t : INT ;
DECL    -> surface  id = ADD, u : INT, v : INT ;
DECL    -> define   id = ADD ;
DECL    -> function id ( ARGS ) = ADD ;
DECL    -> grid     id : INT , ADD ;
DECL    -> point    id = ADD ;
DECL    -> vector   id = ADD @ ADD ;

ARGS    -> id ARGS
ARGS    -> id

INT     -> [ ADD, ADD ]

ADD     -> ADD + MULT
ADD     -> ADD - MULT
ADD     -> MULT

MULT    -> MULT * UNARY
MULT    -> MULT K
MULT    -> MULT / UNARY
MULT    -> UNARY

UNARY   -> + UNARY
UNARY   -> - UNARY
UNARY   -> * UNARY
UNARY   -> / UNARY
UNARY   -> APP

APP     -> FUNC UNARY
APP     -> EXP

FUNC    -> FUNC ^ UNARY
FUNC    -> FUNC _ var_id
FUNC    -> FUNC '
FUNC    -> func_id

EXP     -> COMP ^ UNARY
EXP     -> COMP

COMP    -> FACT . number
COMP    -> FACT

FACT    -> const
FACT    -> number
FACT    -> var_id
FACT    -> TUPLE

TUPLE   -> ( LIST )

LIST    -> ADD, LIST
LIST    -> ADD

********************************