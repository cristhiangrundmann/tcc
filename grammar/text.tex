\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listing}
\usepackage{minted} 
\usepackage{caption}

\renewcommand{\listlistingname}{Códigos}
\renewcommand{\listingscaption}{Código}

\newenvironment{code}{\captionsetup{type=listing}}{}

\title{Compilador}
\date{}
\author{}

\begin{document}

\maketitle

%\newpage
\section{Linguagem de descrição}

%\newpage
\section{Análise léxica}
A análise léxica tem a função de ler o código-fonte que descreve um programa e abstrair as palavras e símbolos presentes.
Dessa forma, os estágios seguintes se beneficiam dessa abstração. O analisador léxico é chamado de lexer.

As palavras-chave, números, constantes, símbolos, etc. são chamados de lexemas no geral.
Todo lexema deve pertencer a uma classe gramatical.
Por exemplo, o texto \texttt{"1024"} forma um lexema de 4 caracteres e sua classe gramatical é \texttt{NUMBER}.
Conforme a classe, um lexema pode ter atributos.
No caso de \texttt{NUMBER}, o próprio número em forma de ponto flutuante é um atributo.
No caso de um símbolo como \texttt{";"}, não há atributos.

Um lexema, sua classe gramatical e seus atributos juntos formam um token.
Diz-se que a classe gramatical de um token é o tipo do token.

Os tipos de token são:
\begin{itemize}
\item \texttt{COMMENT}: texto livre, começando com \texttt{"\#"} e
terminando com uma quebra de linha ou o fim do código-fonte.
\item \texttt{FUNCTION}: identificador de função definida ou pré-definida.
\item \texttt{NUMBER}: número de ponto flutuante.
\item \texttt{VARIABLE}: identificador de variável de função.
\item \texttt{CONSTANT} identificador de constante definida ou pré-definida.
\item \texttt{DECLARE}: identificador de tipo de objeto.
\item \texttt{UNDEFINED}: identificador não definido ou a ser definido.
\item \texttt{EOI}: fim do código-fonte, caractere nulo(0).
\item Caso final: o lexema é um símbolo e seu tipo é o próprio símbolo.

\end{itemize}

A estrutura \texttt{Lexer}(\ref{lexer}) define o analisador léxico.
\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Lexer
{
    const char *source = nullptr;
    const char *lexeme = nullptr;
    int length = 0;
    int lineno = 0;
    int column = 0;
    TokenType type = TokenType::UNDEFINED;
    double number = 0;
    Table *node = nullptr;
    Table *table = nullptr;

    void advance(bool match = true);
};
\end{minted}
\caption{Estrutura do Lexer}
\label{lexer}
\end{code}

Essa estrutura guarda as informações sobre o token e sobre o código-fonte em geral.

O membro \texttt{source} é a string do código-fonte inteiro.
O membro \texttt{lexeme} aponta para o primeiro caractere lexema atual,
dentro do \texttt{source} e \texttt{length} é o seu comprimento.
Os membros \texttt{lineno} e \texttt{column} indicam o número da linha e coluna do lexema.
O membro \texttt{type} é o tipo do token atual.
Os membros \texttt{number} e \texttt{node} são os atributos do token.
No caso de um número, \texttt{number} é o atributo.
No caso de um identificador, \texttt{node} é sua posição na tabela de símbolos(\ref{table}), 
contendo o tipo de token(\texttt{type}) e argumentos de função(\texttt{argsIndex}), no caso de uma função definida.
O membro \texttt{table} é a tabela de símbolos compartilhada pelos estágios da compilação.

O lexer tem apenas o método \texttt{advance}, que serve para avançar para o próximo token.
O método também é usado para inicializar o lexer e obter o primeiro token do código-fonte,
chamando o método com \texttt{lexeme = source} e \texttt{length = 0}.

O método começa avançando a posição do \texttt{lexeme} a quantidade de \texttt{length} caracteres à direita.
Em seguida, espaços em branco são ignorados, isso inclui espaço, tabulações e quebras de linha.

Se o caractere em \texttt{lexeme} for \texttt{"\#"}, então o token é um comentário(tipo \texttt{COMMENT}),
que se extende até uma quebra de linha ou até o \texttt{EOI}, sem incluí-los.

Se o caractere for nulo(0), então o tipo do token é \texttt{EOI} e \texttt{length = 0}.
Isso faz com que o lexer trave nesse token e nunca mais avance.

Se o caractere for um dígito ou \texttt{"."}, então o token é número(\texttt{NUMBER}),
e é lido pela função \texttt{sscanf}, juntamente com seu comprimento. O atributo \texttt{number} também é atualizado.

Se o caractere pertencer ao alfabeto dos identificadores,
então o lexer o procura na tabela de símbolos obtendo o \texttt{node}.
Com esse valor, o tipo de token e comprimento são obtidos.

Caso contrário, o token é um símbolo, seu tipo é o próprio símbolo e seu comprimento é 1.
%\newpage
\section{Tabela de símbolos}
Os estágios da compilação compartilham uma tabela de símbolos, que é inicializada com palavras-chave,
funções e constantes pré-definidas.
A tabela de símbolos define os atributos dos identificadores,
que são o tipo do token e os argumentos da função. 

A estrutura \texttt{Table}(\ref{table}) define a tabela de símbolos.

\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Table
{
    Table *parent = nullptr;
    std::unique_ptr<Table> children[62];
    int argsIndex = -1;
    int length = 0;
    TokenType type = TokenType::UNDEFINED;
    char character = 0;

    Table *next(char c);
    Table *procString(const char *str, bool match);
    Table *initString(const char *str, TokenType type);
};
\end{minted}
\caption{Tabela de símbolos}
\label{table}
\end{code}

Essa estrutura é uma árvore de prefixos(trie).
Os filhos de um nó correspondem a um caractere do alfabeto \texttt{a-zA-Z0-9}.
Os 26 primeiros filhos são \texttt{a-z}, os próximos 26 são \texttt{A-Z}, e os 10 últimos são \texttt{0-9}.
O membro \texttt{character} representa esse caractere e deve ser o mesmo indicado pela relação do nó com seu pai,
com a excessão da raíz, onde é 0(a raíz representa um identificador vazio).
O membro \texttt{parent} é o pai do nó, ou nulo para a raíz.
Os nós \texttt{children[62]} são os $26+26+10$ filhos.
O tamanho do identificador é \texttt{length}, e seus atributos são \texttt{type} e \texttt{argsIndex}.
Com a excessão das funções pré-definidas, o atributo \texttt{argsIndex} representa os nomes dos argumentos da função,
enquanto \texttt{type} sempre indica o tipo do token.

O método \texttt{next} encontra o filho correspondente ao caractere \texttt{c}, e caso seja nulo,
um novo filho é criado, com valores padrões indicados no código.

O método \texttt{procString} busca o identificador em \texttt{str} na árvore,
usando \texttt{next} para traçar o caminho correto.
A string \texttt{str} indica o início do identificador, mas não termina necessariamente no final dele.
O método para de avançar no primeiro caractere fora do alfabeto dos identificadores.
Se o indicador \texttt{match} estiver ativo, o método buscará o maior identificador definido,
se existir, ou o identificador todo, caso contrário.
Por exemplo(\texttt{match=true)} para \texttt{"sinx"}, o método encontra o identificador \texttt{"sin"},
que é uma função. Ou seja, os identificadores não precisam estar separados por um espaço em branco,
caso não haja ambiguidade.
Caso um objeto de nome \texttt{"sinx"} estivesse definido,
o método encontraria o identificador \texttt{"sinx"}.
Nesse caso, um espaço em branco faz diferença. O modo \texttt{match=true} é o mais comum.

O método \texttt{initString} usa \texttt{procString} para criar o identificador em \texttt{str},
inicializando seu tipo de token com \texttt{type}.

%FIGURA

%\newpage
\section{Análise sintática}
A análise sintática tem a função de identificar as estruturas sintáticas presentes nos tokens gerados pelo lexer.
Um gerador, no estágio seguinte, atribui um significado para as estruturas sintáticas reconhecidas,
gerando as estruturas de dados desejadas. O analisador sintático é chamado de parser.

A gramática livre de contexto (\ref{grammar}) define as regras gramaticais da linguagem.
\begin{code}
\begin{minted}[linenos,frame=single]{ebnf}
PROG    = DECL PROG | ;

DECL    = "param"     id ":" INTS ";" ;
DECL    = "grid"      id ":" GRIDS ";" ;
DECL    = "define"    id "=" EXPR ";" ;
DECL    = "curve"     FDECL "," TINTS ";" ;
DECL    = "surface"   FDECL "," TINTS ";" ;
DECL    = "function"  FDECL ";" ;
DECL    = "point"     id "=" EXPR ";" ;
DECL    = "vector"    id "=" EXPR "@" EXPR ";" ;

FDECL   = id "(" IDS ")" "=" EXPR ;
IDS     = IDS "," id | id ;
TAG     = "+" | "-" | ;
INT     = [ EXPR "," EXPR ] ;
GRID    = [ EXPR "," EXPR "," EXPR ] ;
TINT    = var ":" TAG INT ;
INTS    = INTS "," INT | INT ;
TINTS   = TINTS "," TINT | TINT ;
GRIDS   = GRIDS "," GRID | GRID ;

EXPR    = ADD;
ADD     = ADD "+" JUX | ADD "-" JUX | JUX ;
JUX     = JUX MULT2 | MULT ;
MULT    = MULT "*" UNARY | MULT "/" UNARY | UNARY ;
MULT2   = MULT2 "*" UNARY | MULT2 "/" UNARY | APP ;
UNARY   = "+" UNARY ;
UNARY   = "-" UNARY ;
UNARY   = "*" UNARY ;
UNARY   = "/" UNARY ;
UNARY   = APP ;
APP     = FUNC UNARY | POW ;
FUNC    = FUNC2 "^" UNARY | FUNC2 ;
FUNC2   = FUNC2 "_" var | FUNC2 "'" | func ;

POW     = COMP "^" UNARY | COMP ;
COMP    = COMP "_" num | FACT ;
FACT    = const | num | var | "(" TUPLE ")" ;
TUPLE   = ADD "," TUPLE | ADD ;
\end{minted}
\caption{Gramática completa}
\label{grammar}
\end{code}

A gramática consiste em diversas igualdades.
Os termos que aparecem no lado esquerdo de alguma igualdade são chamados de não-terminais,
e representam um conjunto de sentenças(uma sentença é uma sequência de terminais).
Os outros termos, como \texttt{";"} e \texttt{id}, são terminais,
e correspondem a tokens. Os termos \texttt{id}, \texttt{var}, \texttt{const}
e \texttt{num} representam qualquer token do tipo indicado:
\texttt{UNDEFINED}, \texttt{VARIABLE}, \texttt{CONSTANT} e \texttt{NUMBER}, respectivamente.
Os termos \texttt{"param"}, \texttt{"grid"}, \texttt{"define"}, etc.
representam os tokens do tipo \texttt{DECLARE}, que são os tipos de objeto.

Uma igualdade na gramática é dita uma produção para o não-terminal à esquerda.
O símbolo \texttt{"|"} abrevia uma produção alternativa.
Por exemplo: \texttt{ADD = ADD + JUX | ADD - JUX | JUX}
é uma abreviação de \texttt{ADD = ADD + JUX}, \texttt{ADD = ADD - JUX} e \texttt{ADD = JUX}.
Uma produção pode ser a string vazia, por exemplo: \texttt{TAG = ;}
(o ponto e vírgula no final das igualdades pertence à meta-linguagem).

Uma produção significa que o não-terminal à esquerda pode ser substituído pela forma sentencial à direita.
Uma forma sentencial é uma sequência de terminais e não-terminais.
Por exemplo, \texttt{ADD} pode ser substituído por \texttt{ADD + JUX}.
Nesse caso, \texttt{ADD} deriva \texttt{ADD + JUX}.
Para se obter uma sentença gramaticalmente válida,
deve ser possível obtê-la derivando iterativamente o não-terminal inicial \texttt{PROG}.
Uma gramática é dita ambígua quando existe uma sentença com mais de uma forma de
obtê-la a partir do não-terminal inicial. A gramática (\ref{grammar}) não é ambígua.

O trabalho do parser, então, é achar uma forma de derivar uma sentença a partir de \texttt{PROG}.
O método mais simples de parsing se aplica a gramáticas LL(1).

Num parser LL(1), cada não-terminal possui sua própria subrotina.
As subrotinas simulam a substituição de seu não-terminal associado por uma de suas formas sentenciais possíveis.
Ou seja, uma subrotina simula uma produção de seu não-terminal.
Para decidir qual produção aplicar, as subrotinas devem consultar o token atual.
As propriedades de uma gramática LL(1) garantem que o token atual fornece
informação suficiente para determinar qual é a produção correta e, na falta de produção adequada,
detectar um erro gramatical. Após decidir a produção, a subrotina começa sua simulação.
Os termos da forma sentencial da produção são tratados da esquerda para a direita.
Terminais são comparados com o token atual e um erro é detectado quando os tipos diferem.
Quando são iguais, o lexer avança. Os não-terminais são substituídos imediatamente, através de suas subrotinas.

A simulação de uma produção pode ser interpretada de forma literal.
Os termos da forma sentencial são escritos na mesma ordem.
Os terminais são escritos normalmente. Os não-terminais são abstratos e não podem aparecer na sentença,
portanto devem ser derivados até se obter somente terminais. Isso é obtido chamando sua subrotina.

Por exemplo, considere a produção \texttt{FUNC = FUNC2 \textasciicircum UNARY}.
Para simulá-la, deve-se derivar \texttt{FUNC2}, chamando sua subrotina.
Após a subrotina terminar, o token atual é comparado com \texttt{\textasciicircum},
e caso seja igual, o lexer avança para o próximo token. Em seguida, a subrotina \texttt{UNARY} é chamada.

A estrutura da gramática (\ref{grammar}) é cíclica, fazendo o parser ter uma recursão cíclica.
Isso garante que o tamanho das sentenças válidas seja ilimitado.
Por exemplo, a derivação de \texttt{ADD} pode descer não produções triviais até
se introduzir uma par de parênteses, com o não-terminal \texttt{ADD} no meio.

Essa gramática, apesar de ser não ambígua, não é LL(1), pois é possui recursão à esquerda,
por exemplo: \texttt{ADD = ADD + JUX | ADD - JUX | JUX ;}, e fatoração à esquerda,
por exemplo: \texttt{POW = COMP \textasciicircum UNARY | COMP ;}.
A eliminação dessas propriedades pode ser feita modificando a gramática mas mantendo sua estrutura.
A gramática final é muito parecida com a original, e as diferenças não são difíceis de entender.
Porém, a nova gramática é LL(1), ou seja, o método de parsing LL(1) pode ser aplicado e
a gramática é necessariamente não ambígua.

A estrutura \texttt{Parser} (\ref{parser}) define o parser.

%\newpage
\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Parser
{
    Lexer lexer;
    std::unique_ptr<Table> table = std::make_unique<Table>();
    std::vector<std::vector<Table*>> argList;
    Table *objType = nullptr;
    Table *objName = nullptr;
    Table *tag = nullptr;
    char wrap = 0;
	
    const Table *param
    = table->initString("param", TokenType::DECLARE);
    const Table *sqrt
    = table->initString("sqrt", TokenType::FUNCTION);
    //...

    Parser();
    void advance(bool match = true);
    void removeArgs();

    typedef void Parse();

    void parseProgram(const char *source);

    Parse 
        parseFDecl, parseParam, parseGrid, parseDefine, 
        parseExpr, parseAdd, parseJux, parseUnary
        //...;

    void parseInt(char type);
    void parseInts(char type);

    void parseMult(bool unary);

    virtual void syntaxError(TokenType type);
    virtual void actAdvance();
    virtual void actInt(char type);
    virtual void actDecl();
    virtual void actBinary(char type);
    virtual void actUnary(char type);
};
\end{minted}
\caption{Estrutura parcial do parser}
\label{parser}
\end{code}

O membro \texttt{lexer} é o analisador léxico. O parser controla o avanço dos tokens diretamente.
O membro \texttt{table} é a tabela de símbolo compartilhada pelos estágios da compilação.
O membro \texttt{argList} é uma lista de listas de argumentos de função.
O atributo \texttt{argsIndex} de um token é o índice da lista de seus parâmetros nesse membro.
O membro \texttt{objType} e \texttt{objName} auxiliam o estágio da geração, e correspondem ao tipo de objeto e seu nome.
O membro \texttt{tag} é o nome do argumento marcado em um intervalo do tipo tag.
O membro \texttt{wrap} indica o tipo de conexão marcado num intervalo do tipo tag.
Os membros \texttt{param}, \texttt{sqrt}, etc. são as palavras-chave, funções e constantes pré-definidas.

Os métodos com prefixo \texttt{parse} são as subrotinas dos não-terminais.
A lógica do código foi simplificada, então não há uma correspondência exata.
Os métodos marcados com \texttt{virtual} são implementados pelos geradores.
Eles são chamados pelo parser quando uma estrutura sintática é detectada.
O método \texttt{advance} apenas avança o token, ignora os comentários e chama \texttt{actAdvance}.
O método \texttt{removeArgs} apenas redefine os argumentos de uma função para \texttt{UNDEFINED}, quando sua declaração termina.
%\newpage
\section{Geradores}


\end{document}
