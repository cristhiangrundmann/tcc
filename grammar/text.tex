\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listing}
\usepackage{minted} 
\usepackage{caption}

\renewcommand{\listlistingname}{Códigos}
\renewcommand{\listingscaption}{Código}

\newenvironment{code}{\captionsetup{type=listing}}{}

\title{Compilador}
\date{}
\author{}

\begin{document}

\maketitle

\newpage
\section{Linguagem de descrição}

\newpage
\section{Análise léxica}
A análise léxica tem a função de ler o código-fonte que descreve um programa e abstrair as palavras e símbolos presentes.
Dessa forma, os estágios seguintes se beneficiam dessa abstração. O analisador léxico é chamado de lexer.

As palavras-chave, números, constantes, símbolos, etc. são chamados de lexemas no geral.
Todo lexema deve pertencer a uma classe gramatical.
Por exemplo, o texto \texttt{"1024"} forma um lexema de 4 caracteres e sua classe gramatical é \texttt{NUMBER}.
Conforme a classe, um lexema pode ter atributos.
No caso de \texttt{NUMBER}, o próprio número em forma de ponto flutuante é um atributo.
No caso de um símbolo como \texttt{";"}, não há atributos.

Um lexema, sua classe gramatical e seus atributos juntos formam um token.
Diz-se que a classe gramatical de um token é o tipo do token.

Os tipos de token são:
\begin{itemize}
\item \texttt{COMMENT}: texto livre, começando com \texttt{"\#"} e
terminando com uma quebra de linha ou o fim do código-fonte.
\item \texttt{FUNCTION}: identificador de função definida ou pré-definida.
\item \texttt{NUMBER}: número de ponto flutuante.
\item \texttt{VARIABLE}: identificador de variável de função.
\item \texttt{CONSTANT} identificador de constante definida ou pré-definida.
\item \texttt{DECLARE}: identificador de tipo de objeto.
\item \texttt{UNDEFINED}: identificador não definido ou a ser definido.
\item \texttt{EOI}: fim do código-fonte, caractere nulo(0).
\item Caso final: o lexema é um símbolo e seu tipo é o próprio símbolo.

\end{itemize}

A estrutura \texttt{Lexer}(\ref{lexer}) define o analisador léxico.
\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Lexer
{
    const char *source = nullptr;
    const char *lexeme = nullptr;
    int length = 0;
    int lineno = 0;
    int column = 0;
    TokenType type = TokenType::UNDEFINED;
    double number = 0;
    Table *node = nullptr;
    Table *table = nullptr;

    void advance(bool match = true);
};
\end{minted}
\caption{Estrutura do Lexer}
\label{lexer}
\end{code}

Essa estrutura guarda as informações sobre o token e sobre o código-fonte em geral.

O membro \texttt{source} é a string do código-fonte inteiro.
O membro \texttt{lexeme} aponta para o primeiro caractere lexema atual,
dentro do \texttt{source} e \texttt{length} é o seu comprimento.
Os membros \texttt{lineno} e \texttt{column} indicam o número da linha e coluna do lexema.
O membro \texttt{type} é o tipo do token atual.
Os membros \texttt{number} e \texttt{node} são os atributos do token.
No caso de um número, \texttt{number} é o atributo.
No caso de um identificador, \texttt{node} é sua posição na tabela de símbolos(\ref{table}), 
contendo o tipo de token(\texttt{type}) e argumentos de função(\texttt{argsIndex}), no caso de uma função definida.
O membro \texttt{table} é a tabela de símbolos compartilhada pelos estágios da compilação.

O lexer tem apenas o método \texttt{advance}, que serve para avançar para o próximo token.
O método também é usado para inicializar o lexer e obter o primeiro token do código-fonte,
chamando o método com \texttt{lexeme = source} e \texttt{length = 0}.

O método começa avançando a posição do \texttt{lexeme} a quantidade de \texttt{length} caracteres à direita.
Em seguida, espaços em branco são ignorados, isso inclui espaço, tabulações e quebras de linha.

Se o caractere em \texttt{lexeme} for \texttt{"\#"}, então o token é um comentário(tipo \texttt{COMMENT}),
que se extende até uma quebra de linha ou até o \texttt{EOI}, sem incluí-los.

Se o caractere for nulo(0), então o tipo do token é \texttt{EOI} e \texttt{length = 0}.
Isso faz com que o lexer trave nesse token e nunca mais avançe.

Se o caractere for um dígito ou \texttt{"."}, então o token é número(\texttt{NUMBER}),
e é lido pela função \texttt{sscanf}, juntamente com seu comprimento. O atributo \texttt{number} também é atualizado.

Se o caractere pertencer ao alfabeto dos identificadores,
então o lexer o procura na tabela de símbolos obtendo o \texttt{node}.
Com esse valor, o tipo de token e comprimento são obtidos.

Caso contrário, o token é um símbolo, seu tipo é o próprio símbolo e seu comprimento é 1.
\newpage
\section{Tabela de símbolos}
Os estágios da compilação compartilham uma tabela de símbolos, que é inicializada com palavras-chave,
funções e constantes pré-definidas.
A tabela de símbolos define os atributos dos identificadores,
que são o tipo do token e os argumentos da função. 

A estrutura \texttt{Table}(\ref{table}) define a tabela de símbolos.

\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Table
{
    Table *parent = nullptr;
    std::unique_ptr<Table> children[62];
    int argsIndex = -1;
    int length = 0;
    TokenType type = TokenType::UNDEFINED;
    char character = 0;

    Table *next(char c);
    Table *procString(const char *str, bool match);
    Table *initString(const char *str, TokenType type);
};
\end{minted}
\caption{Tabela de símbolos}
\label{table}
\end{code}

Essa estrutura é uma árvore de prefixos(trie).
Os filhos de um nó correspondem a um caractere do alfabeto \texttt{a-zA-Z0-9}.
Os 26 primeiros filhos são \texttt{a-z}, os próximos 26 são \texttt{A-Z}, e os 10 últimos são \texttt{0-9}.
O membro \texttt{character} representa esse caractere e deve ser o mesmo indicado pela relação do nó com seu pai,
com a excessão da raíz, onde é 0(a raíz representa um identificador vazio).
O membro \texttt{parent} é o pai do nó, ou nulo para a raíz.
Os nós \texttt{children[62]} são os $26+26+10$ filhos.
O tamanho do identificador é \texttt{length}, e seus atributos são \texttt{type} e \texttt{argsIndex}.
Com a excessão das funções pré-definidas, o atributo \texttt{argsIndex} representa os nomes dos argumentos da função,
enquanto \texttt{type} sempre indica o tipo do token.

O método \texttt{next} encontra o filho correspondente ao caractere \texttt{c}, e caso seja nulo,
um novo filho é criado, com valores padrões indicados no código.

O método \texttt{procString} busca o identificador em \texttt{str} na árvore,
usando \texttt{next} para traçar o caminho correto.
A string \texttt{str} indica o início do identificador, mas não termina necessariamente no final dele.
O método para de avançar no primeiro caractere fora do alfabeto dos identificadores.
Se o indicador \texttt{match} estiver ativo, o método buscará o maior identificador definido,
se existir, ou o identificador todo, caso contrário.
Por exemplo(\texttt{match=true)} para \texttt{"sinx"}, o método encontra o identificador \texttt{"sin"},
que é uma função. Ou seja, os identificadores não precisam estar separados por um espaço em branco,
caso não haja ambiguidade. Caso um objeto de nome \texttt{"sinx"} estivesse definido,
o método encontraria o identificador \texttt{"sinx"}. Nesse caso, um espaço em branco faz diferença.

O método \texttt{initString} usa \texttt{procString} para criar o identificador em \texttt{str},
inicializando seu tipo de token com \texttt{type}.

%FIGURA

\newpage
\section{Análise sintática}

\begin{code}
\begin{minted}[linenos,frame=single]{ebnf}
PROG    = DECL PROG | ;

DECL    = "param"     id ":" INTS ";" ;
DECL    = "grid"      id ":" GRIDS ";" ;
DECL    = "define"    id "=" EXPR ";" ;
DECL    = "curve"     FDECL "," TINTS ";" ;
DECL    = "surface"   FDECL "," TINTS ";" ;
DECL    = "function"  FDECL ";" ;
DECL    = "point"     id "=" EXPR ";" ;
DECL    = "vector"    id "=" EXPR "@" EXPR ";" ;

FDECL   = id "(" IDS ")" "=" EXPR ;
IDS     = IDS "," id | id ;
TAG     = "+" | "-" | ;
INT     = [ EXPR "," EXPR ] ;
GRID    = [ EXPR "," EXPR "," EXPR ] ;
TINT    = var ":" TAG INT ;
INTS    = INTS "," INT | INT ;
TINTS   = TINTS "," TINT | TINT ;
GRIDS   = GRIDS "," GRID | GRID ;

EXPR    = ADD;
ADD     = ADD "+" JUX | ADD "-" JUX | JUX ;
JUX     = JUX MULT2 | MULT ;
MULT    = MULT "*" UNARY | MULT "/" UNARY | UNARY ;
MULT2   = MULT2 "*" UNARY | MULT2 "/" UNARY | APP ;
UNARY   = "+" UNARY ;
UNARY   = "-" UNARY ;
UNARY   = "*" UNARY ;
UNARY   = "/" UNARY ;
UNARY   = APP ;
APP     = FUNC UNARY | POW ;
FUNC    = FUNC2 "^" UNARY | FUNC2 ;
FUNC2   = FUNC2 "_" var | FUNC2 "'" | func ;

POW     = COMP "^" UNARY | COMP ;
COMP    = COMP "_" num | FACT ;
FACT    = const | num | var | "(" TUPLE ")" ;
TUPLE   = ADD "," TUPLE | ADD ;
\end{minted}
\caption{Gramática completa}
\label{grammar}
\end{code}

\newpage
\begin{code}
\begin{minted}[linenos,frame=single]{cpp}
struct Parser
{
    Lexer lexer;
    std::unique_ptr<Table> table = std::make_unique<Table>();
    std::vector<std::vector<Table*>> argList;
    Table *objType = nullptr;
    Table *objName = nullptr;
    Table *tag = nullptr;
    char wrap = 0;
	
    const Table *param
    = table->initString("param", TokenType::DECLARE);
    const Table *sqrt
    = table->initString("sqrt", TokenType::FUNCTION);
    //...

    Parser();
    void advance(bool match = true);
    void removeArgs();

    typedef void Parse();

    void parseProgram(const char *source);

    Parse 
        parseFDecl, parseParam, parseGrid, parseDefine, 
        parseExpr, parseAdd, parseJux, parseUnary
        //...;

    void parseInt(char type);
    void parseInts(char type);

    void parseMult(bool unary);

    virtual void syntaxError(TokenType type);
    virtual void actAdvance();
    virtual void actInt(char type);
    virtual void actDecl();
    virtual void actBinary(char type);
    virtual void actUnary(char type);
};
\end{minted}
\caption{Estrutura parcial do parser}
\label{parser}
\end{code}

\newpage
\section{Geradores}


\end{document}
